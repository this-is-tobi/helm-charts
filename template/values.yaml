# -- Provide a name in place of the default application name.
# @section -- General
nameOverride: ""
# -- String to fully override the default application name.
# @section -- General
fullnameOverride: ""

# -- Add labels to all the deployed resources
# @section -- General
commonLabels: {}

global:
  # -- Map or array of environment variables to inject into all containers (`valueFrom` supported).
  # @section -- Global
  env: {}
    # A: "A"
    # B:
    #   valueFrom:
    #     configMapKeyRef:
    #       name: "my-config"
    #       key: "B"
    # C:
    #   valueFrom:
    #     secretKeyRef:
    #       name: "my-secret"
    #       key: "C"
    #
    # - name: "A"
    #   value: "A"
    # - name: "B"
    #   valueFrom:
    #     configMapKeyRef:
    #       name: "my-config"
    #       key: "B"
    # - name: "C"
    #   valueFrom:
    #     secretKeyRef:
    #       name: "my-secret"
    #       key: "C"
  # -- Map of environment variables to inject into a configmap loaded by all containers (`valueFrom` not supported).
  # @section -- Global
  envCm: {}
    # D: "D"
  # -- Map of environment variables to inject into a secret loaded by all containers (`valueFrom` not supported).
  # @section -- Global
  envSecret: {}
    # E: "E"

  # -- Global Docker image registry
  # @section -- Global
  imageRegistry: ""
  # -- Globally shared ingress configuration.
  # @section -- Global
  ingress: {}
    # enabled: false
    # className: ""
    # annotations: {}
    # labels: {}
    # hosts:
    # - backend:
    #     serviceName: ""
    #     portNumber: null
    #   name: "domain.local"
    #   pathType: "Prefix"
    #   path: "/"
    # tls:
    # - secretName: domain.local-tls
    #   hosts:
    #   - domain.local
  # -- Globally shared httproute configuration.
  # @section -- Global
  httpRoute: {}
    # enabled: false
    # annotations: {}
    # labels: {}
    # parentRefs: []
    # - name: my-gateway
    #   namespace: gateway-namespace
    #   sectionName: https
    # hostnames: []
    # - "example.com"
    # - "*.example.com"
    # rules: []
    # - matches:
    #   - path:
    #       type: PathPrefix
    #       value: "/"
    #     headers:
    #     - type: Exact
    #       name: "x-version"
    #       value: "v1"
    #     queryParams:
    #     - type: Exact
    #       name: "debug"
    #       value: "true"
    #     method: GET
    #   filters:
    #   - type: RequestHeaderModifier
    #     requestHeaderModifier:
    #       add:
    #       - name: "x-custom-header"
    #         value: "my-value"
    #   - type: RequestRedirect
    #     requestRedirect:
    #       scheme: https
    #       port: 443
    #   backendRefs:
    #   - name: my-service
    #     port: 80
    #     weight: 100
    #   hosts:
    #   - domain.local

## Gateway API configuration (alternative to Ingress)
## Ref: https://gateway-api.sigs.k8s.io/
gateway:
  # -- Create a Gateway resource. Usually, you reference an existing Gateway managed by the infrastructure team.
  # @section -- Global
  create: false
  # -- Name of the Gateway resource. If not set, uses the release fullname.
  # @section -- Global
  name: ""
  # -- GatewayClass name. Required when creating a Gateway.
  # @section -- Global
  className: ""
  # -- Additional gateway annotations.
  # @section -- Global
  annotations: {}
  # -- Additional gateway labels.
  # @section -- Global
  labels: {}
  # -- Gateway addresses configuration.
  # @section -- Global
  addresses: []
  # - type: IPAddress
  #   value: "192.168.1.100"
  # - type: Hostname
  #   value: "gateway.example.com"
  # -- Gateway listeners configuration.
  # @section -- Global
  listeners: []
  # - name: http
  #   port: 80
  #   protocol: HTTP
  #   hostname: "*.example.com"
  #   allowedRoutes:
  #     namespaces:
  #       from: Same  # Same, All, or Selector
  #     kinds:
  #     - kind: HTTPRoute
  # - name: https
  #   port: 443
  #   protocol: HTTPS
  #   hostname: "*.example.com"
  #   tls:
  #     mode: Terminate  # Terminate or Passthrough
  #     certificateRefs:
  #     - kind: Secret
  #       name: example-com-tls
  #   allowedRoutes:
  #     namespaces:
  #       from: Same


servicename:
  # -- Should the app run as a Deployment, StatefulSet or DaemonSet.
  # @section -- Servicename
  workload:
    type: deployment # deployment | statefulset | daemonset
  # -- The number of application controller pods to run.
  # @section -- Servicename
  replicaCount: 1
  image:
    # -- Registry to use for the app.
    # @section -- Servicename
    registry: "docker.io"
    # -- Repository to use for the app.
    # @section -- Servicename
    repository: "debian"
    # -- Image pull policy for the app.
    # @section -- Servicename
    pullPolicy: "IfNotPresent"
    # -- Tag to use for the app.
    # @section -- Servicename
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  ingress:
    # -- Whether or not ingress should be enabled.
    # @section -- Servicename
    enabled: false
    # -- Defines which ingress controller will implement the resource.
    # @section -- Servicename
    className: ""
    # -- Additional ingress annotations.
    # @section -- Servicename
    annotations: {}
    # -- Additional ingress labels.
    # @section -- Servicename
    labels: {}
    hosts:
    - backend:
        # -- Name of the backend service linked to the host record (leave empty to use the app service).
        # @section -- Servicename
        serviceName: ""
        # -- Port used by the backend service linked to the host record (leave null to use the app service port).
        # @section -- Servicename
        portNumber: null
      # -- Name of the host record.
      # @section -- Servicename
      name: "domain.local"
      # -- Path type of the host record.
      # @section -- Servicename
      pathType: "Prefix"
      # -- Path of the host record to manage routing.
      # @section -- Servicename
      path: "/"
    # -- Enable TLS configuration.
    # @section -- Servicename
    tls: []
    # - secretName: domain.local-tls
    #   hosts:
    #   - domain.local
  ## Gateway API HTTPRoute configuration (alternative to Ingress)
  ## Ref: https://gateway-api.sigs.k8s.io/api-types/httproute/
  httpRoute:
    # -- Enable an HTTPRoute resource for this service.
    # @section -- Servicename
    enabled: false
    # -- Additional HTTPRoute annotations.
    # @section -- Servicename
    annotations: {}
    # -- Additional HTTPRoute labels.
    # @section -- Servicename
    labels: {}
    # -- Parent references (Gateways) to attach the HTTPRoute to.
    # @section -- Servicename
    parentRefs: []
    # - name: my-gateway
    #   namespace: gateway-namespace  # optional
    #   sectionName: https            # optional, specific listener name
    # -- Hostnames for the HTTPRoute to match.
    # @section -- Servicename
    hostnames: []
    # - "example.com"
    # - "api.example.com"
    # -- Routing rules for the HTTPRoute.
    # @section -- Servicename
    rules: []
    # - matches:
    #   - path:
    #       type: PathPrefix     # PathPrefix, Exact, or RegularExpression
    #       value: "/"
    #     headers:
    #     - type: Exact
    #       name: "x-version"
    #       value: "v1"
    #     method: GET
    #   filters:
    #   - type: RequestHeaderModifier
    #     requestHeaderModifier:
    #       add:
    #       - name: "x-custom-header"
    #         value: "my-value"
    #   backendRefs:
    #   - name: my-service       # defaults to chart service if not set
    #     port: 80               # defaults to service port if not set
    #     weight: 100            # for traffic splitting
  ## Gateway API GRPCRoute configuration (for gRPC services)
  ## Ref: https://gateway-api.sigs.k8s.io/api-types/grpcroute/
  grpcRoute:
    # -- Enable a GRPCRoute resource for this service.
    # @section -- Servicename
    enabled: false
    # -- Additional GRPCRoute annotations.
    # @section -- Servicename
    annotations: {}
    # -- Additional GRPCRoute labels.
    # @section -- Servicename
    labels: {}
    # -- Parent references (Gateways) to attach the GRPCRoute to.
    # @section -- Servicename
    parentRefs: []
    # - name: my-gateway
    #   namespace: gateway-namespace
    #   sectionName: grpc
    # -- Hostnames for the GRPCRoute to match.
    # @section -- Servicename
    hostnames: []
    # - "grpc.example.com"
    # -- Routing rules for the GRPCRoute.
    # @section -- Servicename
    rules: []
    # - matches:
    #   - method:
    #       type: Exact          # Exact or RegularExpression
    #       service: "mypackage.MyService"
    #       method: "MyMethod"
    #     headers:
    #     - type: Exact
    #       name: "x-version"
    #       value: "v1"
    #   backendRefs:
    #   - name: my-grpc-service
    #     port: 50051
    #     weight: 100
  # -- Annotations for the app deployed pods.
  # @section -- Servicename
  podAnnotations: {}
  # -- Labels for the app deployed pods.
  # @section -- Servicename
  podLabels: {}
  # -- Toggle and define pod-level security context.
  # @section -- Servicename
  podSecurityContext: {}
    # fsGroup: 2000
  # -- Init containers to add to the app pod.
  # @section -- Servicename
  initContainers: []
  # - name: wait-for-keycloak
  #   image: docker.io/curlimages/curl:latest
  #   command:
  #   - "/bin/sh"
  #   - "-c"
  #   args:
  #   - "while [ $(curl -sw '%{http_code}' http://webapp.svc.cluster.local -o /dev/null) -ne 200 ]; do sleep 5; echo 'Waiting for the webapp...'; done"
  #   volumeMounts:
  #   - mountPath: /custom-volume
  #     name: custom-volume
  # -- Extra containers to add to the app pod as sidecars.
  # @section -- Servicename
  extraContainers: []
  # - name: fluentd
  #   image: "fluentd"
  #   volumeMounts:
  #     - mountPath: /my-volume/config
  #       name: config
  # -- Servicename container port number.
  # @section -- Servicename
  containerPort: &servicenameContainerPort 8080
  # -- Servicename container port name.
  # @section -- Servicename
  containerPortName: "http"
  # -- Servicename extra container ports.
  # @section -- Servicename
  extraPorts: []
  # - containerPort: 9090
  #   protocol: "TCP"
  # -- Servicename container command.
  # @section -- Servicename
  command: []
  # -- Servicename container command args.
  # @section -- Servicename
  args: []
  # -- Toggle and define container-level security context.
  # @section -- Servicename
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000
  # -- Servicename container env variables loaded from configmap or secret reference.
  # @section -- Servicename
  envFrom: []
  # - configMapRef:
  #     name: my-config
  # - secretRef:
  #     name: my-secret
  # -- Map or array of environment variables to inject into the app container (`valueFrom` supported).
  # @section -- Global
  env: {}
    # A: "A"
    # B:
    #   valueFrom:
    #     configMapKeyRef:
    #       name: "my-config"
    #       key: "B"
    # C:
    #   valueFrom:
    #     secretKeyRef:
    #       name: "my-secret"
    #       key: "C"
    #
    # - name: "A"
    #   value: "A"
    # - name: "B"
    #   valueFrom:
    #     configMapKeyRef:
    #       name: "my-config"
    #       key: "B"
    # - name: "C"
    #   valueFrom:
    #     secretKeyRef:
    #       name: "my-secret"
    #       key: "C"
  # -- Map of environment variables to inject into a configmap loaded by the app container (`valueFrom` not supported).
  # @section -- Global
  envCm: {}
    # D: "D"
  # -- Map of environment variables to inject into a secret loaded by the app container (`valueFrom` not supported).
  # @section -- Global
  envSecret: {}
    # E: "E"
  probes:
    startupProbe:
      httpGet:
        # -- Servicename container healthcheck endpoint (startupProbe is defined using `toYaml` so it is possible to override it completely).
        # @section -- Servicename
        path: "/"
        # -- Port to use for healthcheck (defaults to container port).
        # @section -- Servicename
        port: *servicenameContainerPort
      # -- Number of seconds after the container has started before probe is initiated.
      # @section -- Servicename
      initialDelaySeconds: 0
      # -- Minimum consecutive successes for the probe to be considered successful after having failed.
      # @section -- Servicename
      successThreshold: 1
      # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
      # @section -- Servicename
      failureThreshold: 10
      # -- How often (in seconds) to perform the probe.
      # @section -- Servicename
      periodSeconds: 10
      # -- Number of seconds after which the probe times out.
      # @section -- Servicename
      timeoutSeconds: 5
    readinessProbe:
      httpGet:
        # -- Servicename container healthcheck endpoint (readinessProbe is defined using `toYaml` so it is possible to override it completely).
        # @section -- Servicename
        path: "/"
        # -- Port to use for healthcheck (defaults to container port).
        # @section -- Servicename
        port: *servicenameContainerPort
      # -- Number of seconds after the container has started before probe is initiated.
      # @section -- Servicename
      initialDelaySeconds: 10
      # -- Minimum consecutive successes for the probe to be considered successful after having failed.
      # @section -- Servicename
      successThreshold: 2
      # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
      # @section -- Servicename
      failureThreshold: 2
      # -- How often (in seconds) to perform the probe.
      # @section -- Servicename
      periodSeconds: 10
      # -- Number of seconds after which the probe times out.
      # @section -- Servicename
      timeoutSeconds: 5
    livenessProbe:
      httpGet:
        # -- Servicename container healthcheck endpoint (livenessProbe is defined using `toYaml` so it is possible to override it completely).
        # @section -- Servicename
        path: "/"
        # -- Port to use for healthcheck (defaults to container port).
        # @section -- Servicename
        port: *servicenameContainerPort
      # -- Number of seconds after the container has started before probe is initiated.
      # @section -- Servicename
      initialDelaySeconds: 30
      # -- Minimum consecutive successes for the probe to be considered successful after having failed.
      # @section -- Servicename
      successThreshold: 1
      # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
      # @section -- Servicename
      failureThreshold: 3
      # -- How often (in seconds) to perform the probe.
      # @section -- Servicename
      periodSeconds: 30
      # -- Number of seconds after which the probe times out.
      # @section -- Servicename
      timeoutSeconds: 5
  strategy:
    # -- Strategy type used to replace old Pods by new ones, can be `Recreate` or `RollingUpdate`.
    # @section -- Servicename
    type: "RollingUpdate"
    rollingUpdate:
      # -- The maximum number of pods that can be unavailable during the update process.
      # @section -- Servicename
      maxUnavailable: 1
      # -- The maximum number of pods that can be scheduled above the desired number of pods.
      # @section -- Servicename
      maxSurge: 1
  updateStrategy:
    # -- UpdateStrategy type used to replace old Pods by new ones, can be `OnDelete` or `RollingUpdate`.
    # @section -- Servicename
    type: "RollingUpdate"
    rollingUpdate:
      # -- The maximum number of pods that can be unavailable during the update process.
      # @section -- Servicename
      maxUnavailable: 1
      # -- The maximum number of pods that can be scheduled above the desired number of pods.
      # @section -- Servicename
      maxSurge: 1
  # -- Image credentials configuration.
  # @section -- Servicename
  imagePullSecrets: []
  # - name: "pullsecret-name-1"
  #   create: false
  # - name: "pullsecret-name-2"
  #   create: true
  #   registry: ""
  #   username: ""
  #   password: ""
  #   email: ""
  # -- Host aliases that will be injected at pod-level into /etc/hosts.
  # @section -- Servicename
  hostAliases: []
  # - ip: "127.0.0.1"
  #   hostnames:
  #   - "foo.local"
  #   - "bar.local"
  # - ip: "10.1.2.3"
  #   hostnames:
  #   - "foo.remote"
  #   - "bar.remote"
  # -- List of volumes to add.
  # @section -- Servicename
  volumes: []
  # - name: config-volume
  #   configMap:
  #     name: log-config
  #     items:
  #       - key: log_level
  #         path: log_level.conf
  # - name: cache-volume
  #   emptyDir:
  #     sizeLimit: 500Mi
  # - name: image-volume
  #   image:
  #     reference: quay.io/crio/artifact:v2
  #     pullPolicy: IfNotPresent
  # -- List of volumeClaims to add.
  # @section -- Servicename
  volumeClaims: []
  # - metadata:
  #     name: app-volume
  #   spec:
  #     accessModes: [ "ReadWriteOnce" ]
  #     storageClassName: "my-storage-class"
  #     resources:
  #       requests:
  #         storage: 1Gi
  # -- List of mounts to add (normally used with `volumes` or `volumeClaims`).
  # @section -- Servicename
  volumeMounts: []
  # - name: config-volume
  #   mountPath: /app/config
  #   subPath: config
  #   readOnly: true
  #   mountPropagation: None
  #   recursiveReadOnly: Enabled
  # - name: cache-volume
  #   mountPath: /app/cache
  # - name: image-volume
  #   mountPath: /app/content
  # - name: storage-volume
  #   mountPath: /app/storage
  service:
    # -- Type of service to create for the app.
    # @section -- Servicename
    type: "ClusterIP"
    # -- Port used by the service.
    # @section -- Servicename
    port: 80
    # -- Port used when type is `NodePort` to expose the service on the given node port.
    # @section -- Servicename
    nodePort: 31000
    # -- Port name used by the service.
    # @section -- Servicename
    portName: "http"
    # -- Protocol used by the service.
    # @section -- Servicename
    protocol: "TCP"
    # -- Extra service ports.
    # @section -- Servicename
    extraPorts: []
    # - port: 9090
    #   targetPort: 9090
    #   protocol: "TCP"
    #   name: "metrics"
  resources:
    requests:
      # -- Memory request for the app.
      # @section -- Servicename
      memory: "256Mi"
      # -- CPU request for the app.
      # @section -- Servicename
      cpu: "100m"
      # Other stuff like GPU, etc could be added here.
      # nvidia.com/gpu: "1"
      # ephemeral-storage: "100Mi"
    limits:
      # -- Memory limit for the app.
      # @section -- Servicename
      memory: "2Gi"
      # -- CPU limit for the app.
      # @section -- Servicename
      cpu: "500m"
      # Other stuff like GPU, etc could be added here.
      # nvidia.com/gpu: "1"
      # ephemeral-storage: "500Mi"
  autoscaling:
    # -- Enable Horizontal Pod Autoscaler for the app.
    # @section -- Servicename
    enabled: false
    # -- Minimum number of replicas for the app.
    # @section -- Servicename
    minReplicas: 1
    # -- Maximum number of replicas for the app.
    # @section -- Servicename
    maxReplicas: 3
    # -- Average CPU utilization percentage for the app.
    # @section -- Servicename
    targetCPUUtilizationPercentage: 80
    # -- Average memory utilization percentage for the app.
    # @section -- Servicename
    targetMemoryUtilizationPercentage: 80
  # -- Revision history limit for the app.
  # @section -- Servicename
  revisionHistoryLimit: 10
  # -- Default node selector for app.
  # @section -- Servicename
  nodeSelector: {}
    # kubernetes.io/os: "linux"
    # kubernetes.io/arch: "amd64"
    # kubernetes.io/hostname: "node1"
  # -- Default tolerations for app.
  # @section -- Servicename
  tolerations: []
  # - key: "key1"
  #   operator: "Equal"
  #   value: "value1"
  #   effect: "NoSchedule"
  #   tolerationSeconds: 3600
  # - key: "key2"
  #   operator: "Equal"
  #   value: "value2"
  #   effect: "NoExecute"
  #   tolerationSeconds: 3600
  # - key: "key3"
  #   operator: "Exists"
  #   effect: "PreferNoSchedule"
  #   tolerationSeconds: 3600
  # -- Affinity used for app pod.
  # @section -- Servicename
  affinity: {}
    # podAntiAffinity:
    #   requiredDuringSchedulingIgnoredDuringExecution:
    #   - labelSelector:
    #       matchExpressions:
    #       - key: "app.kubernetes.io/name"
    #         operator: "In"
    #         values:
    #         - "chartname-servicename"
    #     topologyKey: "kubernetes.io/hostname"
  serviceAccount:
    # -- Enable the service account.
    # @section -- Servicename
    enabled: false
    # -- Create a service account.
    # @section -- Servicename
    create: false
    # -- Annotations applied to created service account.
    # @section -- Servicename
    annotations: {}
    # -- Service account name.
    # @section -- Servicename
    name: ""
    # -- Should the service account access token be automount in the pod.
    # @section -- Servicename
    automountServiceAccountToken: false
    role:
      # -- Should the role be created.
      # @section -- Servicename
      create: false
      # -- Role rules associated with the service account.
      # @section -- Servicename
      rules: []
      # - apiGroups:
      #   - argoproj.io
      #   resources:
      #   - applications
      #   - applicationsets
      #   - appprojects
      #   verbs:
      #   - create
      #   - get
      #   - list
      #   - watch
      #   - update
      #   - delete
      #   - patch
    clusterRole:
      # -- Should the clusterRole be created.
      # @section -- Servicename
      create: false
      # -- ClusterRole rules associated with the service account.
      # @section -- Servicename
      rules: []
      # - apiGroups:
      #   - argoproj.io
      #   resources:
      #   - applications
      #   - applicationsets
      #   - appprojects
      #   verbs:
      #   - create
      #   - get
      #   - list
      #   - watch
      #   - update
      #   - delete
      #   - patch
  ## Ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  pdb:
    # -- Deploy a PodDisruptionBudget for the app
    # @section -- Servicename
    enabled: false
    # -- Labels to be added to app pdb.
    # @section -- Servicename
    labels: {}
    # -- Annotations to be added to app pdb.
    # @section -- Servicename
    annotations: {}
    # -- Number of pods that are available after eviction as number or percentage (eg.: 50%).
    # @section -- Servicename
    # @default -- `""` (defaults to 0 if not specified)
    minAvailable: ""
    # -- Number of pods that are unavailable after eviction as number or percentage (eg.: 50%). Has higher precedence over `servicename.pdb.minAvailable`.
    # @section -- Servicename
    maxUnavailable: ""
  networkPolicy:
    # -- Create NetworkPolicy object for the app.
    # @section -- Servicename
    create: false
    # -- Policy types used in the NetworkPolicy object.
    # @section -- Servicename
    policyTypes:
    - Ingress
    # -- Ingress rules for the NetworkPolicy object.
    # @section -- Servicename
    ingress: []
    # - from:
    #   - ipBlock:
    #       cidr: 172.17.0.0/16
    #       except:
    #       - 172.17.1.0/24
    #   - namespaceSelector:
    #       matchLabels:
    #         project: myproject
    #   - podSelector:
    #       matchLabels:
    #         role: frontend
    #   ports:
    #   - protocol: TCP
    #     port: 6379
    # -- Egress rules for the NetworkPolicy object.
    # @section -- Servicename
    egress: []
    # - to:
    #   - ipBlock:
    #       cidr: 10.0.0.0/24
    #   ports:
    #   - protocol: TCP
    #     port: 32000
    #     endPort: 32768
  metrics:
    # -- Deploy metrics service.
    # @section -- Servicename
    enabled: false
    service:
      # -- Metrics service annotations.
      # @section -- Servicename
      annotations: {}
      # -- Metrics service labels.
      # @section -- Servicename
      labels: {}
      # -- Metrics service port.
      # @section -- Servicename
      port: 9000
      # -- Metrics service target port.
      # @section -- Servicename
      targetPort: 9000
    serviceMonitor:
      # -- Enable a prometheus ServiceMonitor.
      # @section -- Servicename
      enabled: false
      # -- Prometheus ServiceMonitor labels.
      # @section -- Servicename
      labels: {}
      # -- Prometheus ServiceMonitor annotations.
      # @section -- Servicename
      annotations: {}
      endpoints:
      - basicAuth:
          # -- The secret in the service monitor namespace that contains the username for authentication.
          # @section -- Servicename
          username: ""
          # -- The secret in the service monitor namespace that contains the password for authentication.
          # @section -- Servicename
          password: ""
        bearerTokenSecret:
          # -- Secret name to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
          # @section -- Servicename
          name: ""
          # -- Secret key to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
          # @section -- Servicename
          key: ""
        # -- Prometheus ServiceMonitor interval.
        # @section -- Servicename
        interval: "30s"
        # -- Prometheus ServiceMonitor scrapeTimeout. If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
          # @section -- Servicename
        scrapeTimeout: "10s"
        # -- Path used by the Prometheus ServiceMonitor to scrape metrics.
        # @section -- Servicename
        path: "/metrics"
        # -- When true, honorLabels preserves the metric’s labels when they collide with the target’s labels.
        # @section -- Servicename
        honorLabels: false
        # -- Prometheus RelabelConfigs to apply to samples before scraping.
        # @section -- Servicename
        relabelings: []
        # -- Prometheus MetricRelabelConfigs to apply to samples before ingestion.
        # @section -- Servicename
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector.
        # @section -- Servicename
        selector: {}
          # prometheus: kube-prometheus
        # -- Prometheus ServiceMonitor scheme.
        # @section -- Servicename
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig.
        # @section -- Servicename
        tlsConfig: {}

# -- Add extra specs dynamically to this chart.
# @section -- General
extraObjects: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: my-configmap
#   data:
#     key: test
# - apiVersion: secrets.hashicorp.com/v1beta1
#   kind: VaultStaticSecret
#   metadata:
#     name: foo
#     labels:
#       foo/bar: "baz"
#     annotations:
#       foo/bar: "baz"
#   spec:
#     mount: "my-kv"
#     vaultAuthRef: "my-vault-auth"
#     path: "dev/foo"
#     version: 21
#     type: "kv-v2"
#     refreshAfter: "30s"
#     hmacSecretData: true
#     rolloutRestartTargets:
#     - kind: Deployment
#       name: servicename
#     destination:
#       create: true
#       overwrite: true
#       labels:
#         foo/bar: "baz"
#       annotations:
#         foo/bar: "baz"
#       name: foo
#       type: "Opaque"


## Additional services comming from dependencies can be configured below.
## Ref: https://artifacthub.io/packages/helm/this-is-tobi-helm-charts/cnpg-cluster
# cnpg:
#   enabled: false
#   fullnameOverride: servicename-pg-cluster
#   imageName: ghcr.io/cloudnative-pg/postgresql:17.6
#   mode: primary
#   dbName: servicename
#   credentials:
#     username: servicename
#   pvcSize:
#     data: 3Gi
#     wal: 2Gi
#   resources:
#     requests:
#       cpu: 250m
#       memory: 512Mi
#     limits:
#       cpu: 500m
#       memory: 1Gi
