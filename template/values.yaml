# -- Provide a name in place of the default application name.
nameOverride: ""
# -- String to fully override the default application name.
fullnameOverride: ""


# Global configuration.
global:
  # -- Map of environment variables to inject into backend and frontend containers.
  # @section -- Global
  env: {}
  # -- Map of environment variables to inject into backend and frontend containers.
  # @section -- Global
  secrets: {}


# App configuration.
servicename:
  # -- Should the app run as a StatefulSet instead of a Deployment.
  # @section -- App
  statefulset: false
  # -- The number of application controller pods to run.
  # @section -- App
  replicaCount: 1
  ## App image.
  image:
    # -- Repository to use for the app.
    # @section -- App
    repository: "docker.io/debian"
    # -- Image pull policy for the app.
    # @section -- App
    pullPolicy: "IfNotPresent"
    # -- Tag to use for the app.
    # @section -- App
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  ## Ingress configuration.
  ingress:
    # -- Whether or not ingress should be enabled.
    # @section -- App
    enabled: true
    # -- Defines which ingress controller will implement the resource.
    # @section -- App
    className: ""
    # -- Additional ingress annotations.
    # @section -- App
    annotations: {}
    # -- Additional ingress labels.
    # @section -- App
    labels: {}
    hosts:
    - backend:
        # -- Name of the backend service linked to the host record.
        # @section -- App
        serviceName: ""
        # -- Port used by the backend service linked to the host record.
        # @section -- App
        portNumber: null
      # -- Name of the host record.
      # @section -- App
      name: "domain.local"
      # -- Path type of the host record.
      # @section -- App
      pathType: "Prefix"
      # -- Path of the host record to manage routing.
      # @section -- App
      path: "/"
    # -- Enable TLS configuration.
    # @section -- App
    tls: []
    # - secretName: domain.local-tls
    #   hosts:
    #   - domain.local
  # -- Annotations for the app deployed pods.
  # @section -- App
  podAnnotations: {}
  # -- Labels for the app deployed pods.
  # @section -- App
  podLabels: {}
  # -- Toggle and define pod-level security context.
  # @section -- App
  podSecurityContext: {}
    # fsGroup: 2000
  # -- Init containers to add to the app pod.
  # @section -- App
  initContainers: []
  # - name: wait-for-keycloak
  #   image: docker.io/curlimages/curl:latest
  #   command:
  #   - "/bin/sh"
  #   - "-c"
  #   args:
  #   - "while [ $(curl -sw '%{http_code}' http://webapp.svc.cluster.local -o /dev/null) -ne 200 ]; do sleep 5; echo 'Waiting for the webapp...'; done"
  #   volumeMounts:
  #   - mountPath: /custom-volume
  #     name: custom-volume
  container:
    # -- app container port.
    # @section -- App
    port: 8080
    # -- app container command.
    # @section -- App
    command: []
    # -- app container command args.
    # @section -- App
    args: []
    # -- Toggle and define container-level security context.
    # @section -- App
    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000
  # -- Extra containers to add to the app pod as sidecars.
  # @section -- App
  extraContainers: []
  # - name: fluentd
  #   image: "fluentd"
  #   volumeMounts:
  #     - mountPath: /my-volume/config
  #       name: config
  # -- app container env variables loaded from configmap or secret reference.
  # @section -- App
  envFrom: []
  # - configMapRef:
  #     name: my-config
  # - secretRef:
  #     name: my-secret
  # -- app container env variables, it will be injected into a configmap and loaded into the container.
  # @section -- App
  env: {}
  # -- app container env secrets, it will be injected into a secret and loaded into the container.
  # @section -- App
  secrets: {}
  # -- app container healthcheck endpoint.
  # @section -- App
  healthcheckPath: "/"
  ## Deployment strategy for app deployment.
  strategy:
    # -- Strategy type used to replace old Pods by new ones, can be "Recreate" or "RollingUpdate".
    # @section -- App
    type: "RollingUpdate"
  # -- Image credentials configuration.
  # @section -- App
  imagePullSecrets: []
  # - name: "pullsecret-name-1"
  #   create: false
  # - name: "pullsecret-name-2"
  #   create: true
  #   registry: ""
  #   username: ""
  #   password: ""
  #   email: ""
  ## Startup probe for app.
  startupProbe:
    # -- Whether or not enable the probe.
    # @section -- App
    enabled: true
    # -- Number of seconds after the container has started before probe is initiated.
    # @section -- App
    initialDelaySeconds: 0
    # -- Minimum consecutive successes for the probe to be considered successful after having failed.
    # @section -- App
    successThreshold: 1
    # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
    # @section -- App
    failureThreshold: 10
    # -- How often (in seconds) to perform the probe.
    # @section -- App
    periodSeconds: 10
    # -- Number of seconds after which the probe times out.
    # @section -- App
    timeoutSeconds: 5
  ## Readiness probe for app.
  readinessProbe:
    # -- Whether or not enable the probe.
    # @section -- App
    enabled: true
    # -- Number of seconds after the container has started before probe is initiated.
    # @section -- App
    initialDelaySeconds: 10
    # -- Minimum consecutive successes for the probe to be considered successful after having failed.
    # @section -- App
    successThreshold: 2
    # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
    # @section -- App
    failureThreshold: 2
    # -- How often (in seconds) to perform the probe.
    # @section -- App
    periodSeconds: 10
    # -- Number of seconds after which the probe times out.
    # @section -- App
    timeoutSeconds: 5
  ## Liveness probe for app.
  livenessProbe:
    # -- Whether or not enable the probe.
    # @section -- App
    enabled: true
    # -- Number of seconds after the container has started before probe is initiated.
    # @section -- App
    initialDelaySeconds: 30
    # -- Minimum consecutive successes for the probe to be considered successful after having failed.
    # @section -- App
    successThreshold: 1
    # -- Minimum consecutive failures for the probe to be considered failed after having succeeded.
    # @section -- App
    failureThreshold: 3
    # -- How often (in seconds) to perform the probe.
    # @section -- App
    periodSeconds: 30
    # -- Number of seconds after which the probe times out.
    # @section -- App
    timeoutSeconds: 5
  # -- Host aliases that will be injected at pod-level into /etc/hosts.
  # @section -- App
  hostAliases: []
  # - ip: "127.0.0.1"
  #   hostnames:
  #   - "foo.local"
  #   - "bar.local"
  # - ip: "10.1.2.3"
  #   hostnames:
  #   - "foo.remote"
  #   - "bar.remote"
  # -- List of volumes to add.
  # @section -- App
  volumes: []
  # - name: config-volume
  #   configMap:
  #     name: log-config
  #     items:
  #       - key: log_level
  #         path: log_level.conf
  # - name: cache-volume
  #   emptyDir:
  #     sizeLimit: 500Mi
  # - name: image-volume
  #   image:
  #     reference: quay.io/crio/artifact:v2
  #     pullPolicy: IfNotPresent
  # -- List of volumeClaims to add.
  # @section -- App
  volumeClaims: []
  # - metadata:
  #     name: app-volume
  #   spec:
  #     accessModes: [ "ReadWriteOnce" ]
  #     storageClassName: "my-storage-class"
  #     resources:
  #       requests:
  #         storage: 1Gi
  # -- List of mounts to add (normally used with `volumes` or `volumeClaims`).
  # @section -- App
  volumeMounts: []
  # - name: config-volume
  #   mountPath: /app/config
  #   subPath: config
  #   readOnly: true
  #   mountPropagation: None
  #   recursiveReadOnly: Enabled
  # - name: cache-volume
  #   mountPath: /app/cache
  # - name: image-volume
  #   mountPath: /app/content
  # - name: storage-volume
  #   mountPath: /app/storage
  service:
    # -- app service type.
    # @section -- App
    type: "ClusterIP"
    # -- app service port.
    # @section -- App
    port: 80
  resources:
    requests:
      # -- Memory request for the app.
      # @section -- App
      memory: "256Mi"
      # -- CPU request for the app.
      # @section -- App
      cpu: "100m"
    limits:
      # -- Memory limit for the app.
      # @section -- App
      memory: "2Gi"
      # -- CPU limit for the app.
      # @section -- App
      cpu: "500m"
  autoscaling:
    # -- Enable Horizontal Pod Autoscaler ([HPA]) for the app.
    # @section -- App
    enabled: false
    # -- Minimum number of replicas for the app [HPA].
    # @section -- App
    minReplicas: 1
    # -- Maximum number of replicas for the app [HPA].
    # @section -- App
    maxReplicas: 3
    # -- Average CPU utilization percentage for the app [HPA].
    # @section -- App
    targetCPUUtilizationPercentage: 80
    # -- Average memory utilization percentage for the app [HPA].
    # @section -- App
    targetMemoryUtilizationPercentage: 80
  # -- Default node selector for app.
  # @section -- App
  nodeSelector: {}
    # kubernetes.io/os: "linux"
    # kubernetes.io/arch: "amd64"
    # kubernetes.io/hostname: "node1"
  # -- Default tolerations for app.
  # @section -- App
  tolerations: []
  # - key: "key1"
  #   operator: "Equal"
  #   value: "value1"
  #   effect: "NoSchedule"
  #   tolerationSeconds: 3600
  # - key: "key2"
  #   operator: "Equal"
  #   value: "value2"
  #   effect: "NoExecute"
  #   tolerationSeconds: 3600
  # - key: "key3"
  #   operator: "Exists"
  #   effect: "PreferNoSchedule"
  #   tolerationSeconds: 3600
  # -- Default affinity for app.
  # @section -- App
  affinity: {}
    # podAntiAffinity:
    #   requiredDuringSchedulingIgnoredDuringExecution:
    #   - labelSelector:
    #       matchExpressions:
    #       - key: "app.kubernetes.io/name"
    #         operator: "In"
    #         values:
    #         - "chartname-servicename"
    #     topologyKey: "kubernetes.io/hostname"
    # App configuration.
  serviceAccount:
    # -- Enable the service account.
    # @section -- App
    enabled: false
    # -- Create a service account.
    # @section -- App
    create: false
    # -- Annotations applied to created service account.
    # @section -- App
    annotations: {}
    # -- Service account name.
    # @section -- App
    name: "servicename-sa"
    # -- Should the service account access token be automount in the pod.
    # @section -- App
    automountServiceAccountToken: false


# -- Add extra specs dynamically to this chart.
# @section -- Extras
extraObjects: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: my-configmap
#   data:
#     key: {{ .Values.fullname }}
# - |
#   apiVersion: v1
#   kind: Secret
#   metadata:
#     name: my-secret
#   type: Opaque
#   data:
#     password: {{ "secretpassword" | b64enc | quote }}
# - apiVersion: secrets.hashicorp.com/v1beta1
#   kind: VaultStaticSecret
#   metadata:
#     name: foo
#     labels:
#       foo/bar: "baz"
#     annotations:
#       foo/bar: "baz"
#   spec:
#     mount: "my-kv"
#     vaultAuthRef: "my-vault-auth"
#     path: "dev/foo"
#     version: 21
#     type: "kv-v2"
#     refreshAfter: "30s"
#     hmacSecretData: true
#     rolloutRestartTargets:
#     - kind: Deployment
#       name: servicename
#     destination:
#       create: true
#       overwrite: true
#       labels:
#         foo/bar: "baz"
#       annotations:
#         foo/bar: "baz"
#       name: foo
#       type: "Opaque"


# Keycloak configuration.
## Ref: https://artifacthub.io/packages/helm/bitnami/keycloak
# keycloak:
#   enabled: false
#   nameOverride: "keycloak"
#   auth:
#     adminUser: ""
#     adminPassword: ""
#   ingress:
#     enabled: true
#     ingressClassName: ""
#     annotations: {}
#     hostname: "keycloak.domain.local"
#     path: "/"
#     tls: false
#     secrets: []
#   production: true
#   proxy: "edge"
#   tls:
#     enabled: false
#     autoGenerated: false
#   postgresql:
#     nameOverride: "keycloak-db"
#     enabled: true
#     auth:
#       postgresPassword: ""
#       username: ""
#       password: ""
#       database: "keycloak"
#       architecture: "standalone"
