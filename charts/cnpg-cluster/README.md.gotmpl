{{ template "chart.header" . }}

{{ template "chart.badgesSection" . }}

{{ template "chart.description" . }}

{{ template "chart.kubeVersionLine" . }}

{{ template "chart.requirementsSection" . }}

## Installing the Chart

### CLI

**Using Traditional Helm Repository:**
```sh
helm repo add tobi https://this-is-tobi.github.io/helm-charts
helm repo update
helm install <release_name> tobi/{{ template "chart.name" . }}
```

**Using OCI Registry (Recommended):**
```sh
helm install <release_name> oci://ghcr.io/this-is-tobi/helm-charts/{{ template "chart.name" . }} --version {{ template "chart.version" . }}
```

### ArgoCD

**Using Helm Repository:**
```yaml
[...]
sources:
- repoURL: https://this-is-tobi.github.io/helm-charts
  chart: {{ template "chart.name" . }}
  targetRevision: {{ template "chart.version" . }}
  helm:
    releaseName: <release_name>
    parameters: []
    values: ""
```

**Using OCI Registry:**
```yaml
[...]
sources:
- repoURL: ghcr.io/this-is-tobi/helm-charts
  chart: {{ template "chart.name" . }}
  targetRevision: {{ template "chart.version" . }}
  helm:
    releaseName: <release_name>
    parameters: []
    values: ""
```

### Helm dependency

**Using Helm Repository:**
```yaml
# Chart.yaml
[...]
dependencies:
- name: {{ template "chart.name" . }}
  version: {{ template "chart.version" . }}
  repository: https://this-is-tobi.github.io/helm-charts
  condition: {{ template "chart.name" . }}.enabled
```

**Using OCI Registry:**
```yaml
# Chart.yaml
[...]
dependencies:
- name: {{ template "chart.name" . }}
  version: {{ template "chart.version" . }}
  repository: oci://ghcr.io/this-is-tobi/helm-charts
  condition: {{ template "chart.name" . }}.enabled
```

`values.yaml`:

```yaml
[...]
{{ template "chart.name" . }}:
  enabled: true
```

## Quick Start

### Basic Deployment (Auto-Generated Credentials - Recommended)

Deploy a basic 3-instance PostgreSQL cluster with auto-generated secure passwords:

```bash
# Deploy cluster (passwords will be auto-generated)
helm install my-postgres oci://ghcr.io/this-is-tobi/helm-charts/{{ template "chart.name" . }}

# Retrieve the generated application password
kubectl get secret my-postgres-app -o jsonpath='{.data.password}' | base64 -d
```

This creates:
- A 3-instance PostgreSQL cluster with automatic failover
- Auto-generated secure passwords (24 random characters)
- An application user and database named `my-postgres`
- Services for read-write (`my-postgres-rw`) and read-only (`my-postgres-ro`) connections

### Using Kubernetes Secrets (Production Recommended)

For production, manage credentials externally using Kubernetes Secrets:

```bash
# Create secret with your credentials
kubectl create secret generic postgres-app-credentials \
  --from-literal=username=myapp \
  --from-literal=password="$(openssl rand -base64 32)" \
  --type=kubernetes.io/basic-auth

kubectl create secret generic postgres-admin-credentials \
  --from-literal=username=postgres \
  --from-literal=password="$(openssl rand -base64 32)" \
  --type=kubernetes.io/basic-auth

# Deploy using existing secrets
helm install my-postgres oci://ghcr.io/this-is-tobi/helm-charts/{{ template "chart.name" . }} \
  --set credentials.username=myapp \
  --set credentials.existingSecrets.enabled=true \
  --set credentials.existingSecrets.app.secretName=postgres-app-credentials \
  --set credentials.existingSecrets.postgres.secretName=postgres-admin-credentials
```

### Minimal values.yaml

```yaml
# Minimal configuration with auto-generated passwords (recommended)
dbName: myapp
credentials:
  username: myapp_user
  # password and postgresPassword auto-generated by operator
```

## Configuration Examples

> **Avoid embedding passwords, API keys, or credentials directly in values.yaml files or Helm commands.**  
> Always use one of these secure methods:
> - **Auto-generated passwords** (recommended): Leave credentials empty - the operator generates secure 24-character random passwords
> - **Kubernetes Secrets** (production): Use `credentials.existingSecrets.enabled=true` with pre-created secrets
> - **External secret managers**: Integrate with Vault, AWS Secrets Manager, or External Secrets Operator

### Production Setup

High-availability cluster with backups, monitoring, and proper secret management:

```yaml
instances: 3

# Use existing secrets (RECOMMENDED for production)
credentials:
  username: myapp
  existingSecrets:
    enabled: true
    app:
      secretName: "postgres-app-secret"
    postgres:
      secretName: "postgres-admin-secret"

# Backups
backup:
  enabled: true
  destinationPath: "s3://my-bucket/postgres-backups"
  endpointURL: "https://s3.amazonaws.com"
  s3Credentials:
    create: false
    secretName: "s3-backup-credentials"
  retentionPolicy: "30d"

# Monitoring
monitoring:
  enabled: true

# HA configuration
affinity:
  topologyKey: topology.kubernetes.io/zone
```

**Create secrets:**
```bash
kubectl create secret generic postgres-app-secret \
  --from-literal=username=myapp \
  --from-literal=password="$(openssl rand -base64 32)" \
  --type=kubernetes.io/basic-auth

kubectl create secret generic postgres-admin-secret \
  --from-literal=username=postgres \
  --from-literal=password="$(openssl rand -base64 32)" \
  --type=kubernetes.io/basic-auth

kubectl create secret generic s3-backup-credentials \
  --from-literal=accessKeyId="YOUR_KEY" \
  --from-literal=secretAccessKey="YOUR_SECRET"
```

### Development Setup

Minimal resources with auto-generated passwords:

```yaml
instances: 1

credentials:
  username: dev_user
  # Passwords auto-generated

pvcSize:
  data: "5Gi"
  wal: null

resources:
  requests:
    memory: "512Mi"
    cpu: "250m"

enableSuperuserAccess: false
```

### Recovery from Backup

```yaml
mode: "recovery"
instances: 3

credentials:
  username: app_user
  existingSecrets:
    enabled: true
    app:
      secretName: "postgres-app-secret"
    postgres:
      secretName: "postgres-admin-secret"

recovery:
  destinationPath: "s3://my-bucket/postgres-backups"
  endpointURL: "https://s3.amazonaws.com"
  clusterName: "my-postgres"
  s3Credentials:
    create: false
    secretName: "s3-backup-credentials"
  # Optional: point-in-time recovery
  extraArgs:
    recoveryTarget:
      targetTime: "2024-11-24 14:30:00+00"
```

For more advanced scenarios (replicas, connection pooling, custom parameters, etc.), refer to the [values documentation](#values) below.

## Common Use Cases

### 1. Application Database

Create a database and auto-inject connection details into your app:

```yaml
instances: 3
dbName: myapp_production

credentials:
  username: myapp
  # password auto-generated by operator

infosSecret:
  create: true
  secretName: "myapp-db-connection"  # Provides DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASS, DB_URL

backup:
  enabled: true
  destinationPath: "s3://backups/myapp-prod"
  retentionPolicy: "30d"
```

Use in your application deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: app
        envFrom:
        - secretRef:
            name: myapp-db-connection
```

### 2. Multi-Database Cluster

Create multiple databases in one cluster using initialization SQL:

```yaml
instances: 3
credentials:
  username: app_user
  # password auto-generated

initDb:
  extraArgs:
    postInitApplicationSQL:
    - "CREATE DATABASE analytics OWNER app_user;"
    - "CREATE DATABASE reporting OWNER app_user;"
```

For advanced scenarios (external replicas, connection pooling, custom PostgreSQL parameters, major version upgrades, etc.), refer to the [values documentation](#values) below.

## Features

### Database Connection Info Secret

The chart can automatically create a Kubernetes Secret containing all necessary database connection information. This is useful for:
- Application deployments that need database credentials
- Backup tools like `backup-utils`
- Monitoring and maintenance scripts

**Enable the feature:**

```yaml
infosSecret:
  create: true
  secretName: "my-db-connection"  # Optional, defaults to <release-name>-infos
```

**Generated secret contains (keys are configurable):**

| Key | Description | Example | Configurable via |
|-----|-------------|---------|------------------|
| `DB_HOST` | PostgreSQL read-write service hostname | `my-postgres-rw.default.svc` | `infosSecret.keys.host` |
| `DB_PORT` | PostgreSQL port | `5432` | `infosSecret.keys.port` |
| `DB_NAME` | Database name | `myapp` | `infosSecret.keys.name` |
| `DB_USER` | Application username | `myapp_user` | `infosSecret.keys.user` |
| `DB_PASS` | Application password | `generated-password` | `infosSecret.keys.password` |
| `DB_URL` | Full connection string | `postgresql://user:pass@host:5432/db` | `infosSecret.keys.url` |

**Add query parameters to connection URL:**

```yaml
infosSecret:
  create: true
  urlParameters: "sslmode=require&connect_timeout=10&application_name=myapp"
  # Generates: postgresql://user:pass@host:5432/db?sslmode=require&connect_timeout=10&application_name=myapp
```

Common parameters:
- `sslmode` - SSL/TLS mode (`disable`, `require`, `verify-ca`, `verify-full`)
- `connect_timeout` - Connection timeout in seconds
- `application_name` - Application identifier for monitoring
- `options` - PostgreSQL runtime parameters (e.g., `options=-c%20search_path=myschema`)

**Customize environment variable names:**

```yaml
infosSecret:
  create: true
  keys:
    host: "POSTGRES_HOST"             # Instead of DB_HOST
    port: "POSTGRES_PORT"             # Instead of DB_PORT
    name: "POSTGRES_DB"               # Instead of DB_NAME
    user: "POSTGRES_USER"             # Instead of DB_USER
    password: "POSTGRES_PASSWORD"     # Instead of DB_PASS
    url: "DATABASE_URL"               # Instead of DB_URL
```

**Usage example with backup-utils:**

```yaml
# PostgreSQL database
cnpg-cluster:
  enabled: true
  dbName: production
  credentials:
    username: app_user
  infosSecret:
    create: true
    secretName: postgres-connection

# Automated backups
backup-utils:
  enabled: true
  backups:
    postgresBackup:
      enabled: true
      type: postgres
      job:
        schedule: "0 2 * * *"
      envFrom:
        - secretRef:
            name: postgres-connection  # Reference the infos secret
      secrets:
        S3_ENDPOINT: "https://s3.amazonaws.com"
        S3_ACCESS_KEY: "AKIAIOSFODNN7EXAMPLE"
        S3_SECRET_KEY: "secret"
        S3_BUCKET_NAME: "backups"
```

{{ template "chart.valuesSection" . }}

{{ template "chart.maintainersSection" . }}

## Sources

{{ template "chart.homepageLine" . }}

**Source code:**
{{ template "chart.sourcesList" . }}

{{ template "helm-docs.versionFooter" . }}
